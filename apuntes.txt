===========
##Seccion 2:
===========
* EJB un asco hasta la version J2EE 1.4, luego Spring tomo fuerza hasta ahora
* Aprender ambos Spring y Java EE
* Spring Boot 5 Required java 8 or higher and deprecate
* Spring 5 have new specific fetures for this version
* https://spring.io/
* Diferents layers of architecture in spring boot

===========
##Seccion 3:
===========
* Spring permite configurar que clase utilizar a partir de un archivo
* La injeccion de dependencia -> permite el uso controlado de clases de forma estandar
* La invesion de control -> permite que las clases sean utilizadas por un archivo de configuracion
* Configurations in Spring Container
  **) XML config file 
  **) Java annotations
  **) Java Source Code
  * Java Beans -> https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction

===========
##Seccion 5:
===========
* Setter method injection -> injecta a partir del nombre del servicio y lo muta agregando set en el principio
  ej) myService -> setMyService()
* Necesita tener un constructor vacio
* Injecciones literales permite el ingreso de variables sin referencia que pueden ser injectadas dentro de las clases
* Spring nos permite la injeccion de componentes mediante beans y la inverion de dependencia, No es solo un modulo de micro-servicios

===========
##Seccion 6:
===========
* Spring por default sus beans son singleton
  *) Cacheado en memoria
  *) Request segmenteados al mismo bean
  *) Indicando el Scope puedes definir el tipo de instancia
* Existen ciclos de vida en los beans como en angular :0 (init-method, destroy-method)
* For "prototype" scoped beans, Spring does not call the destroy method.  Gasp!

===========
##Seccion 7:
===========
* Annotation, tags que refieren a cierto comportamiento en momento de compilacion como @overwrite
* Java Annotation permite configurar un bean sin necesariamente generar un archivo aparte como xml, solo se debe establecer el contexto a analizar los beans
* Se puede declarar el bean de forma explicita con @Component(variable), y luego ser declarada en la injeccion o puedes tomar el valor por defecto estableciendo el nombre de la clase con el letras en minusculas en la injeccion

===========
##Seccion 8:
===========
* Autowiring (Constructtor , setter and fild injection) -> permite la injeccion automatica de los componentes a partir de los beans expuestos, con lo que puede ser replasado sin castearlo de alguna forma en alguna configuracion.
* En las ultimas versiones incluso no es necesario la annotation @Autowired
* Setter injection puede cambiar el nombre de la funcion, ya que detecta el objeto a ser injectado con autowired y lo settea de forma automatica
* Field injection permite que el control de la injeccion lo maneje de forma autmatica la tecnologia de java llamada "reflection", permitiendo obviar setters y contructors, solo agregando @Autowired a una variable a injectar como servicio.
* Podemos agregar Qualifiers en caso de contar con varias implementaciones, ya que spring solo puede injectar una dependencia por tipo, por lo que hay que realiarlo de forma explicita.
*En caso de tener un Qualifier con mayus, y ser mas de 1 Uppercase, you need to keep the letters in uppercase in that case.
*Los Qualifier en los constructores y en los setters *pueden* ser especificados dentro de los argumentos del method, de igual forma puede ser especificado por fuera del mismo.
* Inject  propertis using Java Annotations -> http://www.luv2code.com/downloads/spring-hibernate/spring-props-annotation-demo.zip *class 74 *

===========
##Seccion 9:
===========
* Mismas funciones antes vistas, pero con nueva nomenclatura
* Con las Java annotations se puede manejar el scope agregando simplemente el tag @Scope
* Eventos @PostConstruct o @PreDestroy en los que puedes manejar los ciclos de vida, utilizando una nueva funcion.
* No entiendo esto -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5389290#questions

===========
##Seccion 10:
===========
* Java code configurations -> ahorrar archivos xml de configuracion por el lado de spring
* En el archivo de configuracion java, disponivilizaremos los diferentes servicios disponibles para su uso, el cual debe ser especificado en "context", cual metodo ultilizaremos segun el bean que queramos.
* Implementacion de Bean en caso real de S3 https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/22289332#questions
* You can use @Bean to make an existing third-party class available to your Spring framework application context.
* Para injectar varoes de un archivo properties es necesario injectar un servicio previamente PropertySourcesPlaceholderConfigurer en las versiones x<=4.3 de Spring

===========
##Seccion 11:
===========
* MVC Spring model -> tienes varios books buenos c;
*Tomcat 9 no permite deployar springboot 4, al momento del video
* La configuracion del MV debe ser realizada por el lado del tomcat, puede ser de forma en xml o por configuraciones en java class
*ref https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5614514#questions

===========
##Seccion 12:
===========
* Tomcat automaticamente checkea los archivos del caliento para hacer cambios en caliente
* los @Controller nos permite manejar el acceso a las rutas y las vistas pueden obtener varibales a partir de estas mediante los modelos
* Injectar assets en pagina monolitica -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5608584#questions
* warfile -> This includes all of your web pages, images, css etc. It also includes the WEB-INF directory which includes your classes in WEB-INF/classes and supporting JAR files in WEB-INF/lib.

===========
##Seccion 13:
===========
* Binding request params nos permite linkear en el constructor del modelo mvc gracias a spring

===========
##Seccion 15:
===========
* java EE no es compatible con spring 5
* Hibernate validator 7 utiliza Jakarta Java EE 9
* Spring 5 no es compatible con Hibernate Validator 7 por consiguiente
* Con Hibernate validator podemos realizar validaciones mediante esta libreria en java
* eliminar tomcat --> netstat -ano | findstr :8080 --> taskkill /PID <PID> /F
===========
##Seccion 16:
===========
* Manejar regexp en java
* Mediante el uso de theBindingResult podemos ver el detalle de los errores del formulario y asi controlar los errores que no conozcamos de forma directa y especifica
* Manejar array de validaciones -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/7407632#questions

===========
##Seccion 18:
===========
* Hibernate -> a framework for retrive data from database -> object to relational mapping (ORM)
* hibernate se comunica con JDBC para soportar las queries
* Hibernate 5.2 utiliza java 8

===========
##Seccion 20:
===========
* Existen 2 formas de manejar el mapping de hibernate (XML & java annotation)
* jpa es el estandar, ya que hace implementacion de hibernate desde abajo (es mejor practica utilizar JPA annotations)

===========
##Seccion 21:
===========
* Elementos principales  sessionFactory & session
* Hibernate permite el mapeo de forma facil en la capa de backend, permitiento tener una mejor idea de lo que existe en bd y realizar valdiaciones al momento de codificar.
* Requiere un doble trabajo ya que aparte de modelar la bd, es necesario modelar las clases en java
* Las peticiones siempre deben ser manejadas de forma que se inicie una conexion e independiente del resultado, finalice la session -> factory.close();
* Read dates with hibernate -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/7314676#overview

===========
##Seccion 22:
===========
* en esta seccion existe una pequeña descripcion del mapeo de bases de datos compuestas en hibernate 

===========
##Seccion 23:
===========
* 1 a 1 -> relaciones de detalles 
* Entity LifeCycle -> Detach, Merge, Persist, Remove, Refresh
* Tipos de cascade -> persist, remove, refresh, detach, merge, all -> puedes configurar 1 o varios tipos
* el Binding bi-directional permite la busqueda desde ambos objetos en caso de necesitar informacion de cualquiera de estos -> no es necesario modificar la db ya que lo realiza con mappingBy annotation
* Importante cerrar las sessiones, como tambien el factorySessions
===========
##Seccion 24:
===========
* la annoation mappedBy apunta a los objetos referenciados a travesd del vinculo establecido en el objeto hijo, en este caso course por la annotation JoinColumn, de esta forma se puede obtener todos los cursos de un instructor y lo mismo al reves.

===========
##Seccion 25:
===========
* Eager vs lazy load -> en backend eager trae todo, lo que causa demora. Se recomienda utilizar lazy load, en caso de requerir solo al instructor, no es necesario traer todos los courses, y cuando sea necesario, los ira a buscar. 
* Lazy loading es determinado en la relacion del annotation, indicando como fetch=FetchType.LAZY
*Defaul Fetch types -> fetch dependiendo del tipo de relacion en bd tiene diferentes estados.
*Lazy Laoading es necesario tener la conexion abierta, ya que en caso de que esto no se cumpla, no podrá hacer la busqueda cuando sea necesaria.

===========
##Seccion 28:
===========
* DAOs -> Data Access Object -> conexion con la base de datos
* Escaneo de Entities -> mediante el bean de sessionFactory, puede buscar todas las entidades mapeadas, indicadas en la propiedad packagesToScan, apuntanto al package requerido.
* En la sessionFactory va inyectado el dataSource con el cual se autentifica la bd, indicando las credenciales. Esto se relaiza mediante las injecciones. referencia https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5836806#overview

===========
##Seccion 29:
===========
* Manejo de refactor para separar capas Dao, services, controller, view -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5888550#overview
* Projecto con multiple data https://drive.google.com/file/d/1-Q6HLvZxOC8Z9XrIfVkMWe_3ywfHpkYF/view?usp=sharing

===========
##Seccion 33:
===========
*sort values from MVC jsp -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/24414656#overview

===========
##Seccion 34:
===========
*Hay 2 problemas en implementar soluciones directas en las clases -> code Tangling y code Scattering.
*Cross-cutting-concerns es una especie de middleware que esta entre las diferentes capas del sistema.
*AOP -> Aspect-Oriented-Programming
** ventajas -> reusable modules, resolve code tangling, resolve code scatter, applied selectively based on configuration.
** desventajas -> too many aspects and app flow is hard to fallow, minor performance cost for aspect execution (run-time weaving).
* Details, Terminology & Advice AOP -> https://www.udemy.com/course/spring-hibernate-tutorial/learn/leSpring)
* AOP Framework(Spring AOP, AspectJ)
* Spring AOP mas simple y menos control que AspectJ

===========
##Seccion 36:
===========
* Pointcut expression -> aop -> middlewares -> lifeTime Cycle -> gatillar funciones en momentos que queramos entre los diferentes flujos de la app.
* Podemos apuntar directamener a las clases que necesitamos utilizar AOP.
* este tiene una estructura especifica para indicar los AOP, se encuentran en esta seccion

===========
##Seccion 37:
===========
* Patrones de parametros wildcards para Pointcut espression "*" ".." "()"


===========
##Seccion 38:
===========
* pointcut annotation inherate, Pointcut declarations viene a evitar el codigo repetido.
* se puede condicionar ciertos aop para manejar en base a IFs
* ojo con los getter & setters, ya que pueden caer bajo esta condicion

===========
##Seccion 39:
===========
* puedes controlar el orden con la notacion @Order para manejar su ejecucion de los Aspect AOP
* order is undifined my default, lo que hace que spring maneje por su lada la ejecucion segun su prioridad
* tambien puedes extender en otro archivo los aop que sean necesarios

===========
##Seccion 40:
===========
* Puedes extraer los datos a partir de los middleware aop con @JoinPoint

===========
##Seccion 41:
===========
* con @AfterReturning puedes modificar o obtener los valores luego de haber ejecutado alguna funcion con AOP
* no es necesario retornar algun valor en AOP, solo modificando el objeto a retornar, este queda modificado para la salida de la funcion interceptada

===========
##Seccion 42:
===========
* podemos interceptar los errores con @AfterThrowing y manejarlos o continuar con el error añadiendo una nueva funcionalidad

===========
##Seccion 43:
===========
* podemos interceptar los errores con @After se ejecuta antes de @AfterThrowing , pero @after no tiene acceso al error.